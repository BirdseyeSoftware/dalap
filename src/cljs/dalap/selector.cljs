;; This file was generated with dalap-cljsb/uild from
;;
;; src/clj/dalap/selector.clj @ Fri Nov 09 22:55:01 UTC 2012
;;
(ns dalap.selector (:require [dalap.walk :refer (update-in-state)]))
(defn -compose-visitors "Creates a visitor function that passes it's parameter to the\n  given inner-visitor function, then the result of this call is going\n  to be passed to the outer-visitor function, using the same walker\n  on both calls." [inner-visitor outer-visitor] (fn comp-visitor [input walker] (outer-visitor (inner-visitor input walker) walker)))
(defn -wrap-walker "Modifies the walker instance when navigating through the input, you\n  would like to use this function when you want to transform the walker\n  somehow while you are visiting an element of the input. This is intended\n  to be called from a visitor function.\n  " [visitor -wrap-walker-fn] (fn wrapped-visitor [input walker] (visitor input (-wrap-walker-fn input walker))))
(defprotocol NodeMatcher "This protocol provides a function that returns another\n  function that accepts a node from the dalap Tree and tests\n  it matches." (to-node-matcher [selectable]))
(extend-protocol NodeMatcher function (to-node-matcher [sfn] sfn) default (to-node-matcher [type_] (fn type-matcher [node] (= (type node) type_))))
(do (extend-protocol NodeMatcher))
(defprotocol TreeLocMatcher "Provides `to-tree-loc-matcher`, which converts a selector `selectable`\n  into a matcher predicate that matches locations in a dalap input\n  tree. It can match on the type or attributes of the current node or,\n  optionally, also match on the parents of the current\n  node.\n\n  The signature of the generated matcher function is [node, walker],\n  which is the same signature as dalap visitors. Any non-nil /\n  non-false return value is considered a match." (to-tree-loc-matcher [selectable]))
(defn- span [p xs] ((juxt (partial take-while p) (partial drop-while p)) xs))
(defn match-selector "Grabs a single node from history that matches the given selector." [selector? history] (let [[new-history [node & _]] (span (complement selector?) history)] (if (nil? node) [nil history] [node new-history])))
(defn match-selector* "Multiple selector version of match-selector.\n\n  Grabs a node from history that matches a group of selectors,\n  respecting a heriarchy of multiple nodes in between." [selectors history] (loop [current-history history current-selector (first selectors) rest-selectors (rest selectors)] (let [[node new-history] (match-selector current-selector current-history)] (cond (nil? node) [nil history] (and (empty? rest-selectors) (not (empty? new-history))) [nil history] (empty? rest-selectors) [node history] :else (recur new-history (first rest-selectors) (rest rest-selectors))))))
(defn- matching-node [selector history] (first (match-selector* selector history)))
(extend-protocol TreeLocMatcher PersistentVector (to-tree-loc-matcher [selector-vec] (let [selector (map to-node-matcher selector-vec)] (fn location-matcher [_node walker] (let [history-stack (:history walker)] (do (.log js/console (str "node: " _node " hist: " history-stack "\n selector " selector-vec))) (matching-node selector history-stack))))) string (to-tree-loc-matcher [s _walker] (cond (symbol? s) (fn [node _walker] (= node s)) :else (throw (js/Error. (str "No tree-loc-matcher for " (type s)))))) function (to-tree-loc-matcher [sfn] sfn))
(defprotocol IAdaptToVisitor "Adapts other types to dalap visitor function." (to-visitor [adaptable] "Creates a dalap visitor."))
(extend-protocol IAdaptToVisitor cljs.core.PersistentHashMap (to-visitor [m] (fn map-visitor [node _w] (m node))))
(defn- ifn-to-visitor [vfn] (fn single-arg-fn-visitor [node _w] (vfn node)))
(extend-protocol IAdaptToVisitor function (to-visitor [vfn] (ifn-to-visitor vfn)))
(extend-protocol IAdaptToVisitor PersistentVector (to-visitor [v] (fn vec-replacement-value-visitor [_node _walker] v)) string (to-visitor [s] (cond (symbol? s) (fn symbol-replacement-value-visitor [_node _walker] s) (keyword? s) (fn keyword-replacement-value-visitor [node _walker] (s node)) :else (fn string-replacement-value-visitor [node _walker] s))) default (to-visitor [obj] (fn replacement-value-visitor [_node _walker] obj)))
(defn- gen-visitor-from-pred-visitor-pairs [predicates+visitors inspect-node?] (fn predicate-table-visitor [node walker] (if (inspect-node? node) (let [vis (or (some (fn pred-checker [[p? v]] (if (p? node walker) v)) predicates+visitors) (constantly node))] (vis node walker)) node)))
(defn normalize-selector-transformer-pairs [selectors+transformers] (for [[sel transformer] selectors+transformers] [(to-tree-loc-matcher sel) (to-visitor transformer)]))
(defn -gen-decorator "Revisit documentation" [selectors+transformers] (let [inspect-node? identity pairs (partition 2 selectors+transformers) inner-visitor (gen-visitor-from-pred-visitor-pairs (normalize-selector-transformer-pairs pairs) inspect-node?) add-history-to-walker (fn add-hist [node w] (if (inspect-node? node) (update-in-state w :history (fn* [p1__5518#] (conj p1__5518# node))) w))] (fn decorator [visit-fn] (-wrap-walker (-compose-visitors inner-visitor visit-fn) add-history-to-walker))))
(defn gen-visitor "API: Public" ([selectors+transformers fallback-visitor] ((-gen-decorator selectors+transformers) fallback-visitor)))